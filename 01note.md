# 内存管理 #
1. 创建对象,定义变量,调用函数方法都会增加内存的占用  
2. 内存分为堆区(存储对象,方法),栈区(存储指针,变量),代码区,常量区,BSS段,程序开始运行后,只有堆区和栈区可以被控制  
3. 栈区内存出的变量,只要出了作用域就会被释放,但堆区内容不会被释放  
4. OC内存管理的范围是任何继承NSobject的对象,其他基本类型数据因为存在栈区,所以会被自动释放  
# 内存管理的原理 #
```objc
//对象的所有权,能够管理对象的内容为对象的所有者,eg
Person* p = [Person new];   //因为可以通过p指针管理对象[Person new]所以p为其所有者,另外只要有一个所有者在,该对象就不会被回收
//引用计数器,数值为整型,表示对象被引用的次数,即正在有多少东西使用对象,对象刚被创建时,计数器的值为1,值变为0时,则对象销毁

//OC有两种内存管理状态:
//ARC:默认模式,automatic reference count,自动引用计数器
//MRC:手动内存管理,项目->Build Setting->Automatic reference counting 选择No 即可改为手动内存管理

//用对象调用retainCount方法来显示计数器数值
NSLo(@"%lu",p.retainCount);//能够打印出计数器的值
//对计数器的操作
[p retainCount];//获得对象的引用计数器的值
[p release];//对该对象的引用计数器-1
[p retain];//让对象的引用计数器+1
//dealloc方法,当对象的引用计数器为0时自动调用该方法
-(void){
 //对象只要调用该方法,代表对象即将被释放
 //必须调用回父类的dealloc方法,且必须放在最后的位置,告诉子类继承自父类的东西释放
 [super dealloc];
}
//释放的本质是移交管理权,当计数器为0后,对象被dealloc,则对象管理权被移交给动态链表,如果当前没有其他对象使用该空间,则该对象还是在内存中,这时如果再用之前的指针调用对象,开启僵尸对象检测后会报错,为了防止这样的报错,将该指针赋值为nil
```
# 内存管理的原则 #
1. 想使用对象,计数器+1,不想使用-1,只要还有人在使用就不能释放,谁创建谁release,谁retain谁release,
2. 僵尸对象:已经被释放的对象  
3. 野指针:调用僵尸对象的指针  
4. 空指针:指向nil的指针,给空指针发消息不会报错  
5.内存泄漏:程序结束后对象仍未被释放  
# 多个对象内存管理 #
* 对多个对象进行内存管理时,因为需要遵循谁创建谁release的原则,加之对象之间有复杂的关系,会使得代码比较繁琐  
# @property内存管理 #
```objc
//@property的完整格式
//@property(参数,参数)成员变量类型 成员变量名称(去掉下划线) 能够在set方法中自动加入内存管理代码
@property(retain)House *house;
```
* 因为对象通过set更换变量指向的对象时,之前的对象计数器应该减1,新对象的计数器应该加1,所以set时应对旧的成员变量release,并对赋值后的新的成员变量retain  
* 按照如上更改,出现的问题就是成员变量两次访问同一个对象时,没有检查访问的对象是否相同,这样导致重复的release和retain,当第二次访问之前对象的计数器为1时,重复的release会释放对象,无法再retain  
* 解决方法是先进行判断,看两次连续访问是否为同一个对象  
```objc
-(void)setHouse:(House*)house{
    if(_house != house){
     [_house release];
     _house = [house retain];
    }
}
//这样就是标准的set方法
```
# @property的参数 #
![@property的参数列表](http://7xqukt.com1.z0.glb.clouddn.com%20/10.1.png)
* assign 不做内存处理,用于简单类型变量,直接赋值  
* atomic 加锁后属性只有完全加载完才能够操作,手机端不使用,耗资源高,安全性高,该参数为默认,不写时默认加锁  
```objc
@property(nonatomic,retain)House* house;
```
* 另外,参数 (setter = abc,getter = haha:)能够更改set get方法的名称,当有参数时方法名也需要加冒号  

# @class #
* 有时候只需要知道该类,不需要拷贝整个文件,使用@class不会拷贝任何东西,只会告诉该文件有这样一个类可以引用,并不会传递类的信息,只是存在这个类,等实现文件用到时才会去查看该类,所以尽量在.h文件中使用@class  
* 另外,当两个类嵌套包含时,编译会出错,这时也要使用@class.当头文件很多时,之间的引用关系会很复杂,这时如果用import,更改一个文件可能会涉及很多其他文件,所以应使用@class  
* 当需要类内的变量或者方法是再import  
* 循环retain的情况,只能设置一方为assign来解决冲突  
# NSSting类的内存管理 #
* 代码中的字符串只要相同,都指向同一个内存空间  
* 使用NSString时不需要内存管理  
* 字符串创建的值为一个固定内存,格式化创建的又为一个固定内存  
# @autorelease #
* 在自动释放池结束时,会对里面所有对象做一次release,如果一次release无法释放,则会造成内存泄漏  
* 对象在池子中调用autorelease时才会在池子结束自动释放  

